use crate::{
    annotation::Annotation,
    assertion::Assertion,
    attribute_decl,
    attribute_use::AttributeUse,
    builtins::{XS_ANY_SIMPLE_TYPE_NAME, XS_ANY_TYPE_NAME},
    components::{Component, Named},
    element_decl,
    element_decl::ElementDeclaration,
    error::XsdError,
    mapping_context::TopLevelMappable,
    model_group::Compositor,
    particle::{MaxOccurs, Particle},
    shared::TypeDefinition,
    simple_type_def::SimpleTypeDefinition,
    values::{actual_value, ActualValue},
    wildcard::{self, DisallowedNameSet, Wildcard},
    xstypes::{AnyURI, NCName, QName, Sequence, Set},
    AttributeDeclaration, AttributeGroupDefinition, MappingContext, ModelGroup, Ref, Term,
};
use roxmltree::Node;

/// Schema Component: Complex Type Definition, a kind of Type Definition (§3.4)
#[derive(Clone, Debug)]
pub struct ComplexTypeDefinition {
    pub annotations: Sequence<Ref<Annotation>>,
    pub name: Option<NCName>,
    pub target_namespace: Option<AnyURI>,
    pub base_type_definition: TypeDefinition,
    pub final_: Set<DerivationMethod>,
    /// Required if `name` is `None`, otherwise must be `None`.
    pub context: Option<Context>,
    pub derivation_method: Option<DerivationMethod>,
    pub abstract_: bool,
    pub attribute_uses: Set<Ref<AttributeUse>>,
    pub attribute_wildcard: Option<Ref<Wildcard>>,
    pub content_type: ContentType,
    pub prohibited_substitutions: Set<DerivationMethod>,
    pub assertions: Sequence<Ref<Assertion>>,

    /// Indicates that this is a built-in Complex Type Definition generated by the library.
    /// This property is not part of the XSD specification.
    pub is_builtin: bool,
}

#[derive(Clone, Debug)]
pub enum Context {
    Element(Ref<ElementDeclaration>),
    ComplexType(Ref<ComplexTypeDefinition>),
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum DerivationMethod {
    Extension,
    Restriction,
}

impl ActualValue<'_> for DerivationMethod {
    fn convert(src: &str, _parent: Node) -> Self {
        match src {
            "extension" => Self::Extension,
            "restriction" => Self::Restriction,
            _ => panic!("Invalid value for derivation method"),
        }
    }
}

/// Property Record: Content Type (§3.4)
#[derive(Clone, Debug)]
pub enum ContentType {
    Empty,
    Simple {
        simple_type_definition: Ref<SimpleTypeDefinition>,
    },
    ElementOnly {
        particle: Ref<Particle>,
        open_content: Option<OpenContent>,
    },
    Mixed {
        particle: Ref<Particle>,
        open_content: Option<OpenContent>,
    },
}

impl ContentType {
    /// Constructs a `ContentType` from a `ContentTypeVariety` and the corresponding fields.
    /// Panics if the fields are not compatible with the variety.
    fn from_variety(
        variety: ContentTypeVariety,
        particle: Option<Ref<Particle>>,
        open_content: Option<OpenContent>,
        simple_type_definition: Option<Ref<SimpleTypeDefinition>>,
    ) -> Self {
        match variety {
            ContentTypeVariety::Empty => {
                assert!(particle.is_none());
                assert!(open_content.is_none());
                assert!(simple_type_definition.is_none());

                Self::Empty
            }
            ContentTypeVariety::Simple => {
                assert!(particle.is_none());
                assert!(open_content.is_none());
                Self::Simple {
                    simple_type_definition: simple_type_definition.unwrap(),
                }
            }
            ContentTypeVariety::ElementOnly => {
                assert!(simple_type_definition.is_none());
                Self::ElementOnly {
                    particle: particle.unwrap(),
                    open_content,
                }
            }
            ContentTypeVariety::Mixed => {
                assert!(simple_type_definition.is_none());
                Self::Mixed {
                    particle: particle.unwrap(),
                    open_content,
                }
            }
        }
    }

    pub fn variety(&self) -> ContentTypeVariety {
        match self {
            Self::Empty => ContentTypeVariety::Empty,
            Self::Simple { .. } => ContentTypeVariety::Simple,
            Self::ElementOnly { .. } => ContentTypeVariety::ElementOnly,
            Self::Mixed { .. } => ContentTypeVariety::Mixed,
        }
    }

    pub fn particle(&self) -> Option<Ref<Particle>> {
        match self {
            Self::ElementOnly { particle, .. } | Self::Mixed { particle, .. } => Some(*particle),
            Self::Empty | Self::Simple { .. } => None,
        }
    }

    pub fn open_content(&self) -> Option<&OpenContent> {
        match self {
            Self::ElementOnly { open_content, .. } | Self::Mixed { open_content, .. } => {
                open_content.as_ref()
            }
            Self::Empty | Self::Simple { .. } => None,
        }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum ContentTypeVariety {
    Empty,
    Simple,
    ElementOnly,
    Mixed,
}

/// Property Record: Open Content
#[derive(Clone, Debug)]
pub struct OpenContent {
    pub mode: OpenContentMode,
    pub wildcard: Ref<Wildcard>,
}

#[derive(Clone, Debug)]
pub enum OpenContentMode {
    Interleave,
    Suffix,
}

impl ComplexTypeDefinition {
    pub const TAG_NAME: &'static str = "complexType";

    pub(super) fn name_from_xml(complex_type: Node, schema: Node) -> Option<QName> {
        // {name}
        //   The ·actual value· of the name [attribute] if present, otherwise ·absent·.
        let name = complex_type
            .attribute("name")
            .map(|v| actual_value::<String>(v, complex_type));

        // {target namespace}
        //   The ·actual value· of the targetNamespace [attribute] of the <schema> ancestor element
        //   information item if present, otherwise ·absent·.
        let target_namespace = schema
            .attribute("targetNamespace")
            .map(|v| actual_value::<String>(v, complex_type));

        name.map(|name| QName::with_optional_namespace(target_namespace, name))
    }

    pub(super) fn map_from_xml(
        context: &mut MappingContext,
        complex_type: Node,
        schema: Node,
        ancestor_element: Option<Ref<ElementDeclaration>>,
        tlref: Option<Ref<Self>>,
    ) -> Result<Ref<Self>, XsdError> {
        let complex_type_ref = tlref.unwrap_or_else(|| context.reserve::<Self>());

        if let Some(simple_content) = complex_type
            .children()
            .find(|c| c.tag_name().name() == "simpleContent")
        {
            Self::map_with_simple_content(
                context,
                complex_type_ref,
                complex_type,
                simple_content,
                schema,
                ancestor_element,
            )?
        } else if let Some(complex_content) = complex_type
            .children()
            .find(|c| c.tag_name().name() == "complexContent")
        {
            Self::map_with_explicit_complex_content(
                context,
                complex_type_ref,
                complex_type,
                complex_content,
                schema,
                ancestor_element,
            )?
        } else {
            Self::map_with_implicit_complex_content(
                context,
                complex_type_ref,
                complex_type,
                schema,
                ancestor_element,
            )?
        }

        assert!(
            context.components().is_present(complex_type_ref),
            "ComplexTypeDefinition mapper failed to populate ref"
        );
        Ok(complex_type_ref)
    }

    fn map_with_simple_content(
        context: &mut MappingContext,
        complex_type_ref: Ref<Self>,
        complex_type: Node,
        simple_content: Node,
        schema: Node,
        ancestor_element: Option<Ref<ElementDeclaration>>,
    ) -> Result<(), XsdError> {
        let (base_type_definition, derivation_method, content_type) = if let Some(restriction) =
            simple_content
                .children()
                .find(|c| c.tag_name().name() == "restriction")
        {
            // The <restriction> alternative is chosen

            // {base type definition}
            //   The type definition ·resolved· to by the ·actual value· of the base [attribute] on
            //   the <restriction> [...] element appearing as a child of <simpleContent>
            let base_type_definition: TypeDefinition = restriction
                .attribute("base")
                .map(|base| actual_value::<QName>(base, restriction))
                .map(|n| context.resolve(&n).unwrap()) // TODO
                .unwrap();

            // {derivation method}
            //   If the <restriction> alternative is chosen, then restriction [...].
            let derivation_method = DerivationMethod::Restriction;

            // {content type}  A Content Type as follows:
            //   {simple_type_definition}  the appropriate case among the following:
            let simple_type_definition =
                if let TypeDefinition::Complex(base_type_definition) = base_type_definition {
                    context.request(base_type_definition)?;
                    let base_type_definition = base_type_definition.get(context.components());
                    match base_type_definition.content_type {
                        ContentType::Simple { .. } => {
                            // 1 If the {base type definition} is a complex type definition whose
                            //   own {content type} has {variety} simple and the <restriction>
                            //   alternative is chosen, then let B be

                            // 1.1 the simple type definition corresponding to the <simpleType>
                            //   among the [children] of <restriction> if there is one;
                            // TODO

                            // 1.2 otherwise (<restriction> has no <simpleType> among its
                            //   [children]), the simple type definition which is the {simple type
                            //   definition} of the {content type} of the {base type definition} a
                            //   simple type definition as follows:
                            // TODO
                            todo!()
                        }
                        ContentType::Mixed { particle, .. }
                            if particle
                                .get(context.components())
                                .is_emptiable(context.components()) =>
                        {
                            todo!()
                        }
                        _ => {
                            // 5 otherwise ·xs:anySimpleType·.
                            let any_simple_type: TypeDefinition =
                                context.resolve(&XS_ANY_SIMPLE_TYPE_NAME).unwrap(); // TODO
                            any_simple_type.simple().unwrap()
                        }
                    }
                } else {
                    // 5 otherwise ·xs:anySimpleType·.
                    let any_simple_type: TypeDefinition =
                        context.resolve(&XS_ANY_SIMPLE_TYPE_NAME).unwrap(); // TODO
                    any_simple_type.simple().unwrap()
                };
            let content_type = ContentType::Simple {
                // {simple_type_definition}  [from above]
                simple_type_definition,
            };

            (base_type_definition, derivation_method, content_type)
        } else if let Some(extension) = simple_content
            .children()
            .find(|c| c.tag_name().name() == "extension")
        {
            // The <extension> alternative is chosen
            // {base type definition}
            //   The type definition ·resolved· to by the ·actual value· of the base [attribute] on
            //   the [...] <extension> element appearing as a child of <simpleContent>
            let base_type_definition = extension
                .attribute("base")
                .map(|base| actual_value::<QName>(base, extension))
                .map(|n| context.resolve(&n).unwrap()) // TODO
                .unwrap();

            // {derivation method}
            //   If [...] the <extension> alternative is chosen, extension.
            let derivation_method = DerivationMethod::Extension;

            let content_type = ContentType::Simple {
                // {simple_type_definition}  the appropriate case among the following:
                simple_type_definition: match base_type_definition {
                    TypeDefinition::Complex(base_type_definition) => {
                        context.request(base_type_definition)?;
                        let base_type_definition = base_type_definition.get(context.components());
                        // 3 If the {base type definition} is a complex type definition whose own
                        //   {content type} has {variety} simple and the <extension> alternative is
                        //   chosen, then the {simple type definition} of the {content type} of that
                        //   complex type definition;
                        if let ContentType::Simple {
                            simple_type_definition,
                        } = base_type_definition.content_type
                        {
                            simple_type_definition
                        } else {
                            // 5 otherwise ·xs:anySimpleType·
                            let any_simple_type: TypeDefinition =
                                context.resolve(&XS_ANY_SIMPLE_TYPE_NAME).unwrap(); // TODO
                            any_simple_type.simple().unwrap()
                        }
                    }
                    TypeDefinition::Simple(base_type_definition) => {
                        // 4 If the {base type definition} is a simple type definition and the
                        //   <extension> alternative is chosen, then that simple type
                        //   definition;
                        base_type_definition
                    }
                },
            };

            (base_type_definition, derivation_method, content_type)
        } else {
            panic!("Invalid simple content")
        };

        let common = Self::map_common(context, complex_type, schema, ancestor_element);

        let attribute_uses = Self::map_attribute_uses_property(
            context,
            complex_type_ref,
            complex_type,
            Some(simple_content),
            schema,
            derivation_method,
            base_type_definition,
        )?;

        // TODO attribute wildcard

        context.insert(
            complex_type_ref,
            Self {
                base_type_definition,
                derivation_method: Some(derivation_method),
                content_type,
                attribute_uses,
                ..common
            },
        );
        Ok(())
    }

    fn map_with_explicit_complex_content(
        context: &mut MappingContext,
        complex_type_ref: Ref<Self>,
        complex_type: Node,
        complex_content: Node,
        schema: Node,
        ancestor_element: Option<Ref<ElementDeclaration>>,
    ) -> Result<(), XsdError> {
        let content = complex_content
            .children()
            .find(|c| ["restriction", "extension"].contains(&c.tag_name().name()))
            .unwrap();

        // {base type definition}
        //   The type definition ·resolved· to by the ·actual value· of the base [attribute]
        let base_type_definition = content
            .attribute("base")
            .map(|base| actual_value::<QName>(base, content))
            .map(|n| context.resolve(&n).unwrap()) // TODO
            .unwrap();

        // {derivation method}
        //   If the <restriction> alternative is chosen, then restriction, otherwise (the
        //   <extension> alternative is chosen) extension.
        let derivation_method = match content.tag_name().name() {
            "restriction" => DerivationMethod::Restriction,
            "extension" => DerivationMethod::Extension,
            _ => unreachable!(),
        };

        let content_type = ContentType::map_complex(
            context,
            complex_type_ref,
            complex_type,
            Some(complex_content),
            schema,
            derivation_method,
            base_type_definition,
        )?;

        let common = Self::map_common(context, complex_type, schema, ancestor_element);

        let attribute_uses = Self::map_attribute_uses_property(
            context,
            complex_type_ref,
            complex_type,
            Some(complex_content),
            schema,
            derivation_method,
            base_type_definition,
        )?;

        // TODO attribute wildcard

        context.insert(
            complex_type_ref,
            Self {
                base_type_definition,
                derivation_method: Some(derivation_method),
                content_type,
                attribute_uses,
                ..common
            },
        );
        Ok(())
    }

    fn map_with_implicit_complex_content(
        context: &mut MappingContext,
        complex_type_ref: Ref<Self>,
        complex_type: Node,
        schema: Node,
        ancestor_element: Option<Ref<ElementDeclaration>>,
    ) -> Result<(), XsdError> {
        // {base type definition} ·xs:anyType·
        let base_type_definition = context.resolve(&XS_ANY_TYPE_NAME).unwrap(); // TODO

        // {derivation method}    restriction
        let derivation_method = DerivationMethod::Restriction;

        let content_type = ContentType::map_complex(
            context,
            complex_type_ref,
            complex_type,
            None,
            schema,
            derivation_method,
            base_type_definition,
        )?;

        let common = Self::map_common(context, complex_type, schema, ancestor_element);

        let attribute_uses = Self::map_attribute_uses_property(
            context,
            complex_type_ref,
            complex_type,
            None,
            schema,
            derivation_method,
            base_type_definition,
        )?;

        // TODO attribute wildcard

        context.insert(
            complex_type_ref,
            Self {
                base_type_definition,
                derivation_method: Some(derivation_method),
                content_type,
                attribute_uses,
                ..common
            },
        );
        Ok(())
    }

    fn map_common(
        mapping_context: &mut MappingContext,
        complex_type: Node,
        schema: Node,
        ancestor_element: Option<Ref<ElementDeclaration>>,
    ) -> Self {
        // {name}
        //   The ·actual value· of the name [attribute] if present, otherwise ·absent·.
        let name = complex_type
            .attribute("name")
            .map(|v| actual_value::<String>(v, complex_type));

        // {target namespace}
        //   The ·actual value· of the targetNamespace [attribute] of the <schema> ancestor element
        //   information item if present, otherwise ·absent·.
        let target_namespace = schema
            .attribute("targetNamespace")
            .map(|v| actual_value::<String>(v, complex_type));

        // {abstract}
        //   The ·actual value· of the abstract [attribute], if present, otherwise false.
        let abstract_ = complex_type
            .attribute("abstract")
            .map(|v| actual_value::<bool>(v, complex_type))
            .unwrap_or(false);

        // TODO impl, doc
        let prohibited_substitutions = Set::new();

        // TODO same
        let final_ = Set::new();

        // {context}
        //   If the name [attribute] is present, then ·absent·, otherwise (among the ancestor
        //   element information items there will be a nearest <element>), the Element Declaration
        //   corresponding to the nearest <element> information item among the the ancestor element
        //   information items.
        let context = if complex_type.has_attribute("name") {
            None
        } else {
            let ancestor_element = ancestor_element.expect(
                "Expected an unnamed complex type definition to have an ancestor <element>",
            );
            Some(Context::Element(ancestor_element))
        };

        // {assertions}
        //   A sequence whose members are Assertions drawn from the following sources, in order:
        //   1 The {assertions} of the {base type definition}.
        //   2 Assertions corresponding to all the <assert> element information items among the
        //     [children] of <complexType>, <restriction> and <extension>, if any, in document
        //     order.
        // TODO
        let assertions = Sequence::new();

        // {annotations}
        //   The ·annotation mapping· of the set of elements containing the <complexType>, the
        //   <openContent> [child], if present, the <attributeGroup> [children], if present, the
        //   <simpleContent> and <complexContent> [children], if present, and their <restriction>
        //   and <extension> [children], if present, and their <openContent> and <attributeGroup>
        //   [children], if present, as defined in XML Representation of Annotation Schema
        //   Components (§3.15.2).
        let mut annot_elements = vec![complex_type];
        complex_type
            .children()
            // TODO children of simple/complexContent
            .filter(|e| {
                [
                    "openContent",
                    "attributeGroup",
                    "simpleContent",
                    "complexContent",
                ]
                .contains(&e.tag_name().name())
            })
            .for_each(|e| annot_elements.push(e));
        let annotations =
            Annotation::xml_element_set_annotation_mapping(mapping_context, &annot_elements);

        Self {
            annotations,
            name,
            target_namespace,
            final_,
            context,
            abstract_,
            prohibited_substitutions,
            assertions,

            // Populated in the specific mapping implementations
            // TODO restructure
            base_type_definition: mapping_context.resolve(&XS_ANY_TYPE_NAME).unwrap(), // TODO !!
            derivation_method: None,
            content_type: ContentType::Empty,
            attribute_uses: Set::new(),
            attribute_wildcard: None,
            is_builtin: false,
        }
    }

    /// Maps the {attribute uses} property
    fn map_attribute_uses_property(
        context: &mut MappingContext,
        complex_type_ref: Ref<Self>,
        complex_type: Node,
        content_node: Option<Node>,
        schema: Node,
        derivation_method: DerivationMethod,
        base_type_definition: TypeDefinition,
    ) -> Result<Vec<Ref<AttributeUse>>, XsdError> {
        // In the following rule, references to "the [children]" refer to the [children] of the
        // <extension> or <restriction> element (whichever appears as a child of <simpleContent> or
        // <complexContent> in the <complexType> source declaration), if present, otherwise to the
        // [children] of the <complexType> source declaration itself.
        let children_node = content_node
            .and_then(|content_node| {
                content_node
                    .children()
                    .find(|child| ["extension", "restriction"].contains(&child.tag_name().name()))
            })
            .unwrap_or(complex_type);

        // If the <schema> ancestor has a defaultAttributes attribute, and the <complexType>
        // element does not have defaultAttributesApply = false, then the {attribute uses} property
        // is computed as if there were an <attributeGroup> [child] with empty content and a ref
        // [attribute] whose ·actual value· is the same as that of the defaultAttributes
        // [attribute] appearing after any other <attributeGroup> [children]. Otherwise proceed as
        // if there were no such <attributeGroup> [child].
        if schema.has_attribute("defaultAttributes")
            && complex_type
                .attribute("defaultAttributesApply")
                .map(|v| actual_value::<bool>(v, complex_type))
                != Some(false)
        {
            todo!("default attributes")
        } else {
            // Then the value is a union of sets of attribute uses as follows
            let mut attribute_uses = Set::new();

            // 1 The set of attribute uses corresponding to the <attribute> [children], if any.
            attribute_uses.extend(
                children_node
                    .children()
                    .filter(|c| c.tag_name().name() == "attribute")
                    .filter_map(|attribute| {
                        AttributeDeclaration::map_from_xml_local(
                            context,
                            attribute,
                            schema,
                            attribute_decl::ScopeParent::ComplexType(complex_type_ref),
                        )
                        .unwrap() // TODO
                    }),
            );

            // 2 The {attribute uses} of the attribute groups ·resolved· to by the ·actual value·s
            //   of the ref [attribute] of the <attributeGroup> [children], if any.
            for attribute_group in children_node
                .children()
                .filter(|c| c.tag_name().name() == "attributeGroup")
            {
                let ref_ = attribute_group.attribute("ref").unwrap();
                let ref_ = actual_value::<QName>(ref_, complex_type);
                let group = context
                    .resolve::<Ref<AttributeGroupDefinition>>(&ref_)
                    .unwrap(); // TODO
                attribute_uses.extend(context.request(group)?.attribute_uses.iter())
            }

            // 3 The attribute uses "inherited" from the {base type definition} T, as described by
            //   the appropriate case among the following:
            //  3.1 If T is a complex type definition and {derivation method} = extension, then the
            //    attribute uses in T.{attribute uses} are inherited.
            //  3.2 If T is a complex type definition and {derivation method} = restriction, then
            //    the attribute uses in T.{attribute uses} are inherited, with the exception of
            //    those with an {attribute declaration} whose expanded name is one of the
            //    following:
            //   3.2.1 the expanded name of the {attribute declaration} of an attribute use which
            //     has already been included in the set, following the rules in clause 1 or clause
            //     2 above;
            //   3.2.2 the expanded name of the {attribute declaration} of what would have been an
            //     attribute use corresponding to an <attribute> [child], if the <attribute> had
            //     not had use = prohibited. Note: This sub-clause handles the case where the base
            //     type definition T allows the attribute in question, but the restriction
            //     prohibits it.
            //  3.3 otherwise no attribute use is inherited.
            if let TypeDefinition::Complex(base_type_definition) = base_type_definition {
                match derivation_method {
                    DerivationMethod::Extension => attribute_uses
                        .extend(context.request(base_type_definition)?.attribute_uses.iter()),
                    DerivationMethod::Restriction => {
                        // TODO
                    }
                }
            }

            Ok(attribute_uses)
        }
    }
}

impl ContentType {
    fn compute_explicit_content(
        context: &mut MappingContext,
        complex_type_ref: Ref<ComplexTypeDefinition>,
        complex_type: Node,
        children_elem: Node,
        schema: Node,
    ) -> Result<Option<Ref<Particle>>, XsdError> {
        // 2 Let the explicit content be the appropriate case among the following:

        // 2.1 If at least one of the following is true
        // 2.1.1 There is no <group>, <all>, <choice> or <sequence> among the [children];
        let cond_1 = !children_elem
            .children()
            .any(|c| ["group", "all", "choice", "sequence"].contains(&c.tag_name().name()));
        // 2.1.2 There is an <all> or <sequence> among the [children] with no [children] of its own excluding <annotation>;
        let cond_2 = children_elem.children().any(|c| {
            ["all", "sequence"].contains(&c.tag_name().name())
                && !c
                    .children()
                    .any(|c| c.tag_name().name() != Annotation::TAG_NAME)
        });
        // 2.1.3 There is among the [children] a <choice> element whose minOccurs [attribute] has the ·actual value· 0 and which has no [children] of its own except for <annotation>;
        let cond_3 = children_elem.children().any(|c| {
            c.tag_name().name() == "choice"
                && c.attribute("minOccurs")
                    .map(|v| actual_value::<u64>(v, complex_type))
                    == Some(0)
                && !c
                    .children()
                    .any(|c| c.tag_name().name() != Annotation::TAG_NAME)
        });
        // 2.1.4 The <group>, <all>, <choice> or <sequence> element among the [children] has a maxOccurs [attribute] with an ·actual value· of 0;
        let cond_4 = children_elem
            .children()
            .find(|c| ["group", "all", "choice", "sequence"].contains(&c.tag_name().name()))
            .map(|c| {
                c.attribute("maxOccurs")
                    .filter(|m| *m != "unbounded")
                    .map(|v| actual_value::<u64>(v, complex_type))
                    == Some(0)
            })
            == Some(true);
        if cond_1 || cond_2 || cond_3 || cond_4 {
            // then empty
            Ok(None)
        } else {
            // 2.2 otherwise the particle corresponding to the <all>, <choice>, <group> or <sequence> among the [children].
            children_elem
                .children()
                .find_map(|c| match c.tag_name().name() {
                    "all" | "choice" | "sequence" => Some(Particle::map_from_xml_model_group(
                        context,
                        c,
                        schema,
                        element_decl::ScopeParent::ComplexType(complex_type_ref),
                    )),
                    "group" => Some(Particle::map_from_xml_group_reference(context, c)),
                    _ => None,
                })
                .transpose()
        }
    }

    fn map_complex(
        context: &mut MappingContext,
        complex_type_ref: Ref<ComplexTypeDefinition>,
        complex_type: Node,
        complex_content: Option<Node>,
        schema: Node,
        derivation_method: DerivationMethod,
        base_type_definition: TypeDefinition,
    ) -> Result<Self, XsdError> {
        // When the mapping rule below refers to "the [children]", ...
        let children_elem = if let Some(complex_content) = complex_content {
            // ... for a <complexType> source declaration with a <complexContent> child, the
            // [children] of <extension> or <restriction> (whichever appears as a child of
            // <complexContent>) are meant
            complex_content
                .children()
                .find(|c| ["extension", "restriction"].contains(&c.tag_name().name()))
                .unwrap()
        } else {
            // If no <complexContent> is present, then the [children] of the <complexType> source
            // declaration itself are meant
            complex_type
        };

        // 1 Let the effective mixed be the appropriate case among the following:
        let effective_mixed =
            if let Some(mixed) = complex_content.and_then(|cc| cc.attribute("mixed")) {
                // 1.1 If the mixed [attribute] is present on <complexContent>, then its ·actual value·;
                actual_value::<bool>(mixed, complex_type)
            } else if let Some(mixed) = complex_type.attribute("mixed") {
                // 1.2 If the mixed [attribute] is present on <complexType>, then its ·actual value·;
                actual_value::<bool>(mixed, complex_type)
            } else {
                // 1.3 otherwise false.
                false
            };

        // TODO maxOccurs unbounded

        // 2 (explicit content)
        let explicit_content = Self::compute_explicit_content(
            context,
            complex_type_ref,
            complex_type,
            children_elem,
            schema,
        )?;

        // 3 Let the effective content be the appropriate case among the following:
        let effective_content = if let Some(explicit_content) = explicit_content {
            // 3.2 otherwise the ·explicit content·.
            Some(explicit_content)
        } else {
            // 3.1 If the ·explicit content· is empty, then the appropriate case among the
            //   following:
            if effective_mixed {
                // 3.1.1 If the ·effective mixed· is true, then a particle whose properties are as
                //   follows:
                // {min occurs} 1
                // {max occurs} 1
                // {term}       a model group whose {compositor} is sequence and whose {particles}
                //              is empty.
                let term = Term::ModelGroup(context.create(ModelGroup {
                    compositor: Compositor::Sequence,
                    particles: Sequence::new(),
                    annotations: Sequence::new(),
                }));
                Some(context.create(Particle {
                    min_occurs: 1,
                    max_occurs: MaxOccurs::Count(1),
                    term,
                    annotations: None,
                }))
            } else {
                // 3.1.2 otherwise empty.
                None
            }
        };

        // TODO derivation method == None?
        // 4 [explicit content type]
        let explicit_content_type = Self::explicit_content_type(
            derivation_method,
            explicit_content,
            effective_content,
            effective_mixed,
            base_type_definition,
            context,
        )?;

        // 5 Let the wildcard element be the appropriate case among the following:
        let wildcard_element = if let Some(open_content) = children_elem
            .children()
            .find(|c| c.tag_name().name() == "openContent")
        {
            // 5.1 If the <openContent> [child] is present, then the <openContent> [child].
            Some(open_content)
            // 5.2 If the <openContent> [child] is not present, the <schema> ancestor has a
            //   <defaultOpenContent> [child], and one of the following is true
        } else if let Some(default_open_content) = schema
            .children()
            .find(|c| c.tag_name().name() == "defaultOpenContent")
        {
            // 5.2.1 the ·explicit content type· has {variety} ≠ empty
            // 5.2.2 the ·explicit content type· has {variety} = empty and the <defaultOpenContent>
            //   element has appliesToEmpty = true
            if explicit_content_type.variety() != ContentTypeVariety::Empty
                || (explicit_content_type.variety() == ContentTypeVariety::Empty
                    && default_open_content
                        .attribute("appliesToEmpty")
                        .map(|v| actual_value::<bool>(v, complex_type))
                        == Some(true))
            {
                // then the <defaultOpenContent> [child] of the <schema>.
                Some(default_open_content)
            } else {
                // 5.3 otherwise ·absent·.
                None
            }
        } else {
            // 5.3 otherwise ·absent·.
            None
        };

        // 6 Then the value of the property is the appropriate case among the following:
        if wildcard_element
            .map(|e| {
                e.attribute("mode")
                    .map(|v| actual_value::<&str>(v, complex_type))
                    == Some("none")
            })
            .unwrap_or(true)
        {
            // 6.1 If the ·wildcard element· is ·absent· or is present and has mode = 'none', then
            //   the ·explicit content type·.
            Ok(explicit_content_type)
        } else {
            // The wildcard element must be present
            let wildcard_element = wildcard_element.unwrap();

            // 6.2 otherwise
            //   {variety}
            //     The {variety} of the ·explicit content type· if it's not empty; otherwise
            //     element-only.
            let variety = if explicit_content_type.variety() != ContentTypeVariety::Empty {
                explicit_content_type.variety()
            } else {
                ContentTypeVariety::ElementOnly
            };

            //   {particle}
            //     The {particle} of the ·explicit content type· if the {variety} of the ·explicit
            //     content type· is not empty; otherwise a Particle as follows:
            let particle = if explicit_content_type.variety() != ContentTypeVariety::Empty {
                Some(explicit_content_type.particle().unwrap())
            } else {
                // {min occurs} 1
                // {max occurs} 1
                // {term}       a model group whose {compositor} is sequence and whose
                //              {particles} is empty.
                let term = Term::ModelGroup(context.create(ModelGroup {
                    compositor: Compositor::Sequence,
                    particles: Sequence::new(),
                    annotations: Sequence::new(),
                }));
                Some(context.create(Particle {
                    min_occurs: 1,
                    max_occurs: MaxOccurs::Count(1),
                    term,
                    annotations: None,
                }))
            };

            //  {open content} An Open Content as follows:
            let open_content = {
                // {mode}
                //   The ·actual value· of the mode [attribute] of the ·wildcard element·, if
                //   present, otherwise interleave.
                let mode = wildcard_element
                    .attribute("mode")
                    .and_then(|v| match v {
                        "interleave" => Some(OpenContentMode::Interleave),
                        "suffix" => Some(OpenContentMode::Suffix),
                        _ => unreachable!(),
                    })
                    .unwrap_or(OpenContentMode::Interleave);

                // {wildcard}
                //   Let W be the wildcard corresponding to the <any> [child] of the ·wildcard
                //   element·. If the {open content} of the ·explicit content type· is ·absent·,
                //   then W; otherwise a wildcard whose {process contents} and {annotations} are
                //   those of W, and whose {namespace constraint} is the wildcard union of the
                //   {namespace constraint} of W and of {open content}.{wildcard} of the ·explicit
                //   content type·, as defined in Attribute Wildcard Union (§3.10.6.3).
                // TODO
                let _w = wildcard_element
                    .children()
                    .find(|c| c.tag_name().name() == "any")
                    .unwrap();
                let wildcard = context.create(Wildcard {
                    namespace_constraint: wildcard::NamespaceConstraint {
                        variety: wildcard::NamespaceConstraintVariety::Any,
                        namespaces: Set::new(),
                        disallowed_names: DisallowedNameSet::default(),
                    },
                    process_contents: wildcard::ProcessContents::Strict,
                    annotations: Sequence::new(),
                });

                Some(OpenContent { mode, wildcard })
            };

            // {simple type definition} ·absent·
            let simple_type_definition = None;

            Ok(Self::from_variety(
                variety,
                particle,
                open_content,
                simple_type_definition,
            ))
        }
    }

    /// Shared construction code used by both restriction and extension derivation methods
    fn explicit_content_type_shared(
        effective_content: Option<Ref<Particle>>,
        effective_mixed: bool,
    ) -> Self {
        if let Some(effective_content) = effective_content {
            // 4.1.2 otherwise a Content Type as follows:
            // {variety}                 mixed if the ·effective mixed· is true, otherwise
            //                           element-only
            // {particle}                The ·effective content·
            // {open content}           ·absent·
            // {simple type definition} ·absent·
            if effective_mixed {
                ContentType::Mixed {
                    particle: effective_content,
                    open_content: None,
                }
            } else {
                ContentType::ElementOnly {
                    particle: effective_content,
                    open_content: None,
                }
            }
        } else {
            // 4.1.1 If the ·effective content· is empty , then a Content Type as follows:
            // {variety}                empty
            // {particle}               ·absent·
            // {open content}           ·absent·
            // {simple type definition} ·absent·
            ContentType::Empty
        }
    }

    fn explicit_content_type(
        derivation_method: DerivationMethod,
        explicit_content: Option<Ref<Particle>>,
        effective_content: Option<Ref<Particle>>,
        effective_mixed: bool,
        base_type_definition: TypeDefinition,
        context: &mut MappingContext,
    ) -> Result<ContentType, XsdError> {
        // 4 Let the explicit content type be the appropriate case among the following:
        if derivation_method == DerivationMethod::Restriction {
            // 4.1 If {derivation method} = restriction, then the appropriate case among the
            //   following:
            Ok(Self::explicit_content_type_shared(
                effective_content,
                effective_mixed,
            ))
        } else {
            // 4.2 If {derivation method} = extension, then the appropriate case among the
            //   following:

            // 4.2.1 If the {base type definition} is a simple type definition or is a complex type
            //   definition whose {content type}.{variety} = empty or simple, then a Content Type
            //   as per clause 4.1.1 and clause 4.1.2 above;
            let is_first_case = match base_type_definition {
                TypeDefinition::Simple(_) => true,
                TypeDefinition::Complex(c) => matches!(
                    context.request(c)?.content_type.variety(),
                    ContentTypeVariety::Empty | ContentTypeVariety::Simple
                ),
            };

            if is_first_case {
                return Ok(Self::explicit_content_type_shared(
                    effective_content,
                    effective_mixed,
                ));
            }

            // The base type must be a complex type here
            let base_type_definition = base_type_definition.complex().unwrap();
            let base_type_definition = context.request(base_type_definition)?;

            // 4.2.2 If the {base type definition} is a complex type definition whose {content
            //   type}.{variety} = element-only or mixed and the ·effective content· is empty, then
            //   {base type definition}.{content type};
            if matches!(
                base_type_definition.content_type.variety(),
                ContentTypeVariety::ElementOnly | ContentTypeVariety::Mixed
            ) && effective_content.is_none()
            {
                return Ok(base_type_definition.content_type.clone());
            };

            // 4.2.3 otherwise a Content Type as follows:

            // {variety} mixed if the ·effective mixed· is true, otherwise element-only
            let variety = if effective_mixed {
                ContentTypeVariety::Mixed
            } else {
                ContentTypeVariety::ElementOnly
            };

            // {open content}
            //   the {open content} of the {content type} of the {base type definition}.
            let open_content = base_type_definition.content_type.open_content().cloned();

            // {particle}
            //   Let the base particle be the particle of the {content type} of the {base type
            //   definition}.
            // TODO None particle?
            let base_particle = base_type_definition.content_type.particle().unwrap();
            let base_particle_d = base_particle.get(context.components());

            let base_has_compositor_all = base_particle_d
                .term
                .model_group()
                .map(|mg| mg.get(context.components()).compositor == Compositor::All)
                .unwrap_or(false);

            //   Then the appropriate case among the following:
            // TODO Non-modelgroup term?
            let particle = if base_has_compositor_all && explicit_content.is_none() {
                // 4.2.3.1 If the {term} of the ·base particle· has {compositor} all and the
                //   ·explicit content· is empty, then the ·base particle·.
                Some(base_particle)
            } else if base_has_compositor_all
                && effective_content
                    .map(|ec| {
                        ec.get(context.components())
                            .term
                            .model_group()
                            .map(|mg| mg.get(context.components()).compositor == Compositor::All)
                            .unwrap_or(false)
                    })
                    .unwrap_or(false)
            {
                // 4.2.3.2 If the {term} of the ·base particle· has {compositor} all and the {term}
                //   of the ·effective content· also has {compositor} all, then a Particle whose
                //   properties are as follows:

                // {term}
                //   a model group whose {compositor} is all and whose {particles} are the
                //   {particles} of the {term} of the ·base particle· followed by the {particles}
                //   of the {term} of the ·effective content·.
                let particles = base_particle_d
                    .term
                    .model_group()
                    .unwrap()
                    .get(context.components())
                    .particles
                    .iter()
                    .copied()
                    .chain(
                        effective_content
                            .unwrap()
                            .get(context.components())
                            .term
                            .model_group()
                            .unwrap()
                            .get(context.components())
                            .particles
                            .iter()
                            .copied(),
                    )
                    .collect();
                let term = context.create(ModelGroup {
                    compositor: Compositor::All,
                    particles,
                    annotations: Sequence::new(),
                });
                Some(
                    context.create(Particle {
                        min_occurs: effective_content
                            .unwrap()
                            .get(context.components())
                            .min_occurs,
                        max_occurs: MaxOccurs::Count(1),
                        term: Term::ModelGroup(term),
                        annotations: None,
                    }),
                )
            } else {
                // TODO effective content None?
                let mg = context.create(ModelGroup {
                    compositor: Compositor::Sequence,
                    particles: vec![base_particle, effective_content.unwrap()],
                    annotations: Sequence::new(),
                });
                Some(context.create(Particle {
                    min_occurs: 1,
                    max_occurs: MaxOccurs::Count(1),
                    term: Term::ModelGroup(mg),
                    annotations: None,
                }))
            };

            Ok(Self::from_variety(variety, particle, open_content, None))
        }
    }
}

impl Component for ComplexTypeDefinition {
    const DISPLAY_NAME: &'static str = "ComplexTypeDefinition";

    fn is_builtin(&self) -> bool {
        self.is_builtin
    }
}

impl Named for ComplexTypeDefinition {
    fn name(&self) -> Option<QName> {
        self.name.as_ref().map(|local_name| {
            QName::with_optional_namespace(self.target_namespace.as_ref(), local_name)
        })
    }
}

impl TopLevelMappable for ComplexTypeDefinition {
    fn map_from_top_level_xml(
        context: &mut MappingContext,
        self_ref: Ref<Self>,
        complex_type: Node,
        schema: Node,
    ) -> Result<(), XsdError> {
        Self::map_from_xml(context, complex_type, schema, None, Some(self_ref))?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        builtins,
        complex_type_def::ContentType,
        mapping_context::{MappingContext, TopLevel},
        xstypes::QName,
        BuiltinOverwriteAction, ComplexTypeDefinition, RootContext,
    };
    use roxmltree::Document;

    #[test]
    fn explicit_content_extension() {
        const SCHEMA: &str = r#"
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <xs:complexType name="base" />
                <xs:complexType name="extension">
                    <xs:complexContent>
                        <xs:extension base="base">
                            <xs:sequence>
                                <xs:element name="child" type="xs:string" />
                            </xs:sequence>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:schema>
        "#;
        let schema_doc = Document::parse(SCHEMA).unwrap();
        let schema = schema_doc.root_element();
        let mut root_context = RootContext::new(BuiltinOverwriteAction::Deny, &[]);
        builtins::register_builtins(&mut root_context);
        let mut context = MappingContext::new(&mut root_context, schema);

        let base_node = schema
            .children()
            .find(|c| c.attribute("name") == Some("base"))
            .unwrap();
        let extension_node = schema
            .children()
            .find(|c| c.attribute("name") == Some("extension"))
            .unwrap();
        let children_elem = extension_node
            .first_element_child()
            .unwrap()
            .first_element_child()
            .unwrap();

        let base = context.reserve::<ComplexTypeDefinition>();
        context.register_with_name(QName::without_namespace("base"), base);
        context.top_level_refs.insert(base_node, base);

        let extension = context.reserve::<ComplexTypeDefinition>();
        context.register_with_name(QName::without_namespace("extension"), extension);
        context.top_level_refs.insert(extension_node, extension);

        let particle = ContentType::compute_explicit_content(
            &mut context,
            extension,
            extension_node,
            children_elem,
            schema,
        )
        .unwrap();
        assert!(particle.is_some());
    }
}
