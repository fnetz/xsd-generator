//!Generated by dt-xsd-generator 0.1.0
#![allow(dead_code, unused_imports)]
use dt_builtins::meta;
use meta::SimpleType as _;
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum TypeType {
    ///Enumeration value for `` simple ``
    Simple,
    ///Enumeration value for `` extended ``
    Extended,
    ///Enumeration value for `` title ``
    Title,
    ///Enumeration value for `` resource ``
    Resource,
    ///Enumeration value for `` locator ``
    Locator,
    ///Enumeration value for `` arc ``
    Arc,
}
impl meta::SimpleType for TypeType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "simple" => Ok(Self::Simple),
            "extended" => Ok(Self::Extended),
            "title" => Ok(Self::Title),
            "resource" => Ok(Self::Resource),
            "locator" => Ok(Self::Locator),
            "arc" => Ok(Self::Arc),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub struct HrefType(pub dt_builtins::AnyURI);
impl meta::SimpleType for HrefType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::AnyURI::from_literal(normalized)?;
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct RoleType(pub dt_builtins::AnyURI);
impl meta::SimpleType for RoleType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::AnyURI::from_literal(normalized)?;
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct ArcroleType(pub dt_builtins::AnyURI);
impl meta::SimpleType for ArcroleType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::AnyURI::from_literal(normalized)?;
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct TitleAttrType(pub String);
impl meta::SimpleType for TitleAttrType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        Ok(Self(value))
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum ShowType {
    ///Enumeration value for `` new ``
    New,
    ///Enumeration value for `` replace ``
    Replace,
    ///Enumeration value for `` embed ``
    Embed,
    ///Enumeration value for `` other ``
    Other,
    ///Enumeration value for `` none ``
    None,
}
impl meta::SimpleType for ShowType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "new" => Ok(Self::New),
            "replace" => Ok(Self::Replace),
            "embed" => Ok(Self::Embed),
            "other" => Ok(Self::Other),
            "none" => Ok(Self::None),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum ActuateType {
    ///Enumeration value for `` onLoad ``
    OnLoad,
    ///Enumeration value for `` onRequest ``
    OnRequest,
    ///Enumeration value for `` other ``
    Other,
    ///Enumeration value for `` none ``
    None,
}
impl meta::SimpleType for ActuateType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "onLoad" => Ok(Self::OnLoad),
            "onRequest" => Ok(Self::OnRequest),
            "other" => Ok(Self::Other),
            "none" => Ok(Self::None),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub struct LabelType(pub String);
impl meta::SimpleType for LabelType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct FromType(pub String);
impl meta::SimpleType for FromType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct ToType(pub String);
impl meta::SimpleType for ToType {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        Ok(Self(value))
    }
}
#[derive(Debug)]
pub struct Simple {
    pub wildcards: Vec<()>,
    pub r#type: Option<TypeType>,
    pub href: Option<HrefType>,
    pub role: Option<RoleType>,
    pub arcrole: Option<ArcroleType>,
    pub title: Option<TitleAttrType>,
    pub show: Option<ShowType>,
    pub actuate: Option<ActuateType>,
}
#[derive(Debug)]
pub enum ExtendedInner {
    Title(TitleEltType),
    Resource(ResourceType),
    Locator(LocatorType),
    Arc(ArcType),
}
#[derive(Debug)]
pub struct Extended {
    inner: ExtendedInner,
    pub r#type: TypeType,
    pub role: Option<RoleType>,
    pub title: Option<TitleAttrType>,
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum LangInner {
    ///Enumeration value for ``  ``
    Empty,
}
impl meta::SimpleType for LangInner {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "" => Ok(Self::Empty),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub enum Lang {
    Language(dt_builtins::Language),
    Unnamed(LangInner),
}
impl meta::SimpleType for Lang {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = None;
    fn from_literal(s: &str) -> Result<Self, meta::Error> {
        if let Ok(value) = dt_builtins::Language::from_string(s) {
            Ok(Self::Language(value))
        } else if let Ok(value) = LangInner::from_string(s) {
            Ok(Self::Unnamed(value))
        } else {
            Err(meta::Error::NoValidBranch)
        }
    }
}
#[derive(Debug)]
pub struct TitleEltType {
    pub wildcards: Vec<()>,
    pub r#type: TypeType,
    pub lang: Option<Lang>,
}
#[derive(Debug)]
pub struct ResourceType {
    pub wildcards: Vec<()>,
    pub r#type: TypeType,
    pub role: Option<RoleType>,
    pub title: Option<TitleAttrType>,
    pub label: Option<LabelType>,
}
#[derive(Debug)]
pub struct LocatorType {
    pub titles: Vec<TitleEltType>,
    pub r#type: TypeType,
    pub href: HrefType,
    pub role: Option<RoleType>,
    pub title: Option<TitleAttrType>,
    pub label: Option<LabelType>,
}
#[derive(Debug)]
pub struct ArcType {
    pub titles: Vec<TitleEltType>,
    pub r#type: TypeType,
    pub arcrole: Option<ArcroleType>,
    pub title: Option<TitleAttrType>,
    pub show: Option<ShowType>,
    pub actuate: Option<ActuateType>,
    pub from: Option<FromType>,
    pub to: Option<ToType>,
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum Status {
    ///Enumeration value for `` submitted ``
    Submitted,
    ///Enumeration value for `` accepted ``
    Accepted,
    ///Enumeration value for `` stable ``
    Stable,
    ///Enumeration value for `` queried ``
    Queried,
    ///Enumeration value for `` disputed-test ``
    DisputedTest,
    ///Enumeration value for `` disputed-spec ``
    DisputedSpec,
}
impl meta::SimpleType for Status {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "submitted" => Ok(Self::Submitted),
            "accepted" => Ok(Self::Accepted),
            "stable" => Ok(Self::Stable),
            "queried" => Ok(Self::Queried),
            "disputed-test" => Ok(Self::DisputedTest),
            "disputed-spec" => Ok(Self::DisputedSpec),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub struct BugUri(pub dt_builtins::AnyURI);
impl meta::SimpleType for BugUri {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::AnyURI::from_literal(normalized)?;
        Ok(Self(value))
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum TestOutcome {
    ///Enumeration value for `` valid ``
    Valid,
    ///Enumeration value for `` invalid ``
    Invalid,
    ///Enumeration value for `` notKnown ``
    NotKnown,
    ///Enumeration value for `` runtime-schema-error ``
    RuntimeSchemaError,
}
impl meta::SimpleType for TestOutcome {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "valid" => Ok(Self::Valid),
            "invalid" => Ok(Self::Invalid),
            "notKnown" => Ok(Self::NotKnown),
            "runtime-schema-error" => Ok(Self::RuntimeSchemaError),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum ExpectedOutcomeInner {
    ///Enumeration value for `` implementation-defined ``
    ImplementationDefined,
    ///Enumeration value for `` implementation-dependent ``
    ImplementationDependent,
    ///Enumeration value for `` indeterminate ``
    Indeterminate,
    ///Enumeration value for `` invalid-latent ``
    InvalidLatent,
}
impl meta::SimpleType for ExpectedOutcomeInner {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "implementation-defined" => Ok(Self::ImplementationDefined),
            "implementation-dependent" => Ok(Self::ImplementationDependent),
            "indeterminate" => Ok(Self::Indeterminate),
            "invalid-latent" => Ok(Self::InvalidLatent),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub enum ExpectedOutcome {
    TestOutcome(TestOutcome),
    Unnamed(ExpectedOutcomeInner),
}
impl meta::SimpleType for ExpectedOutcome {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = None;
    fn from_literal(s: &str) -> Result<Self, meta::Error> {
        if let Ok(value) = TestOutcome::from_string(s) {
            Ok(Self::TestOutcome(value))
        } else if let Ok(value) = ExpectedOutcomeInner::from_string(s) {
            Ok(Self::Unnamed(value))
        } else {
            Err(meta::Error::NoValidBranch)
        }
    }
}
#[derive(Debug)]
pub struct VersionInfo(pub Vec<VersionToken>);
impl meta::SimpleType for VersionInfo {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> =
        Some(dt_builtins::meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let list = normalized
            .split(' ')
            .map(|s| VersionToken::from_literal(s))
            .collect::<Result<Vec<_>, _>>()?;
        Ok(Self(list))
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum KnownXsdVersion {
    ///Enumeration value for `` 1.0 ``
    _10,
    ///Enumeration value for `` 1.1 ``
    _11,
}
impl meta::SimpleType for KnownXsdVersion {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "1.0" => Ok(Self::_10),
            "1.1" => Ok(Self::_11),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum Xsd10Editions {
    ///Enumeration value for `` 1.0-1e ``
    _101e,
    ///Enumeration value for `` 1.0-2e ``
    _102e,
}
impl meta::SimpleType for Xsd10Editions {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "1.0-1e" => Ok(Self::_101e),
            "1.0-2e" => Ok(Self::_102e),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum XmlSubstrate {
    ///Enumeration value for `` XML-1.0 ``
    Xml10,
    ///Enumeration value for `` XML-1.0-1e-4e ``
    Xml101e4e,
    ///Enumeration value for `` XML-1.0-5e ``
    Xml105e,
    ///Enumeration value for `` XML-1.1 ``
    Xml11,
}
impl meta::SimpleType for XmlSubstrate {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "XML-1.0" => Ok(Self::Xml10),
            "XML-1.0-1e-4e" => Ok(Self::Xml101e4e),
            "XML-1.0-5e" => Ok(Self::Xml105e),
            "XML-1.1" => Ok(Self::Xml11),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum UnicodeVersions {
    ///Enumeration value for `` Unicode_4.0.0 ``
    Unicode400,
    ///Enumeration value for `` Unicode_6.0.0 ``
    Unicode600,
}
impl meta::SimpleType for UnicodeVersions {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "Unicode_4.0.0" => Ok(Self::Unicode400),
            "Unicode_6.0.0" => Ok(Self::Unicode600),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum RuntimeSchemaError {
    ///Enumeration value for `` CTR-all-compile ``
    CtrAllCompile,
    ///Enumeration value for `` CTR-all-runtime ``
    CtrAllRuntime,
    ///Enumeration value for `` CTR-all-idep ``
    CtrAllIdep,
}
impl meta::SimpleType for RuntimeSchemaError {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "CTR-all-compile" => Ok(Self::CtrAllCompile),
            "CTR-all-runtime" => Ok(Self::CtrAllRuntime),
            "CTR-all-idep" => Ok(Self::CtrAllIdep),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum XpathInCta {
    ///Enumeration value for `` restricted-xpath-in-CTA ``
    RestrictedXpathInCta,
    ///Enumeration value for `` full-xpath-in-CTA ``
    FullXpathInCta,
}
impl meta::SimpleType for XpathInCta {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "restricted-xpath-in-CTA" => Ok(Self::RestrictedXpathInCta),
            "full-xpath-in-CTA" => Ok(Self::FullXpathInCta),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum XdmFiltering {
    ///Enumeration value for `` comments-and-PIs-excluded ``
    CommentsAndPIsExcluded,
    ///Enumeration value for `` comments-and-PIs-included ``
    CommentsAndPIsIncluded,
}
impl meta::SimpleType for XdmFiltering {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "comments-and-PIs-excluded" => Ok(Self::CommentsAndPIsExcluded),
            "comments-and-PIs-included" => Ok(Self::CommentsAndPIsIncluded),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub enum KnownToken {
    KnownXsdVersion(KnownXsdVersion),
    Xsd10Editions(Xsd10Editions),
    XmlSubstrate(XmlSubstrate),
    UnicodeVersions(UnicodeVersions),
    RuntimeSchemaError(RuntimeSchemaError),
    XpathInCta(XpathInCta),
    XdmFiltering(XdmFiltering),
}
impl meta::SimpleType for KnownToken {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = None;
    fn from_literal(s: &str) -> Result<Self, meta::Error> {
        if let Ok(value) = KnownXsdVersion::from_string(s) {
            Ok(Self::KnownXsdVersion(value))
        } else if let Ok(value) = Xsd10Editions::from_string(s) {
            Ok(Self::Xsd10Editions(value))
        } else if let Ok(value) = XmlSubstrate::from_string(s) {
            Ok(Self::XmlSubstrate(value))
        } else if let Ok(value) = UnicodeVersions::from_string(s) {
            Ok(Self::UnicodeVersions(value))
        } else if let Ok(value) = RuntimeSchemaError::from_string(s) {
            Ok(Self::RuntimeSchemaError(value))
        } else if let Ok(value) = XpathInCta::from_string(s) {
            Ok(Self::XpathInCta(value))
        } else if let Ok(value) = XdmFiltering::from_string(s) {
            Ok(Self::XdmFiltering(value))
        } else {
            Err(meta::Error::NoValidBranch)
        }
    }
}
#[derive(Debug)]
pub enum VersionToken {
    KnownToken(KnownToken),
    Decimal(dt_builtins::Decimal),
    Nmtoken(dt_builtins::NmToken),
}
impl meta::SimpleType for VersionToken {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = None;
    fn from_literal(s: &str) -> Result<Self, meta::Error> {
        if let Ok(value) = KnownToken::from_string(s) {
            Ok(Self::KnownToken(value))
        } else if let Ok(value) = dt_builtins::Decimal::from_string(s) {
            Ok(Self::Decimal(value))
        } else if let Ok(value) = dt_builtins::NmToken::from_string(s) {
            Ok(Self::Nmtoken(value))
        } else {
            Err(meta::Error::NoValidBranch)
        }
    }
}
#[derive(Debug)]
pub struct StatusEntry {
    pub annotations: Vec<Annotation>,
    pub status: Status,
    pub date: dt_builtins::Date,
    pub bugzilla: Option<BugUri>,
}
#[derive(Debug)]
pub struct Ref {
    pub annotations: Vec<Annotation>,
    pub r#type: Option<TypeType>,
    pub href: Option<HrefType>,
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum Role {
    ///Enumeration value for `` principal ``
    Principal,
    ///Enumeration value for `` imported ``
    Imported,
    ///Enumeration value for `` included ``
    Included,
    ///Enumeration value for `` redefined ``
    Redefined,
    ///Enumeration value for `` overridden ``
    Overridden,
}
impl meta::SimpleType for Role {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "principal" => Ok(Self::Principal),
            "imported" => Ok(Self::Imported),
            "included" => Ok(Self::Included),
            "redefined" => Ok(Self::Redefined),
            "overridden" => Ok(Self::Overridden),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub struct SchemaDocumentRef {
    pub annotations: Vec<Annotation>,
    pub role: Option<Role>,
    pub r#type: Option<TypeType>,
    pub href: Option<HrefType>,
}
#[derive(Debug)]
pub struct TestSuite {
    pub annotations: Vec<Annotation>,
    pub test_set_refs: Vec<Ref>,
    pub name: dt_builtins::Name,
    pub release_date: dt_builtins::Date,
    pub schema_version: String,
    pub version: Option<VersionInfo>,
}
#[derive(Debug)]
pub struct TestSet {
    pub annotations: Vec<Annotation>,
    pub test_groups: Vec<TestGroup>,
    pub contributor: String,
    pub name: dt_builtins::Name,
    pub version: Option<VersionInfo>,
}
#[derive(Debug)]
pub struct TestGroup {
    pub annotations: Vec<Annotation>,
    pub documentation_references: Vec<Ref>,
    pub schema_test: Option<SchemaTest>,
    pub instance_tests: Vec<InstanceTest>,
    pub name: dt_builtins::Name,
    pub version: Option<VersionInfo>,
}
#[derive(Debug)]
pub struct SchemaTest {
    pub annotations: Vec<Annotation>,
    pub schema_documents: Vec<SchemaDocumentRef>,
    pub expecteds: Vec<Expected>,
    pub current: Option<StatusEntry>,
    pub priors: Vec<StatusEntry>,
    pub name: dt_builtins::Name,
    pub version: Option<VersionInfo>,
}
#[derive(Debug)]
pub struct InstanceTest {
    pub annotations: Vec<Annotation>,
    pub instance_document: Ref,
    pub expecteds: Vec<Expected>,
    pub current: Option<StatusEntry>,
    pub priors: Vec<StatusEntry>,
    pub name: dt_builtins::Name,
    pub version: Option<VersionInfo>,
}
#[derive(Debug)]
pub struct Expected {
    pub validity: ExpectedOutcome,
    pub version: Option<VersionInfo>,
}
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum PublicationPermission {
    ///Enumeration value for `` W3C members ``
    W3cMembers,
    ///Enumeration value for `` public ``
    Public,
}
impl meta::SimpleType for PublicationPermission {
    const FACET_WHITE_SPACE: Option<meta::Whitespace> = Some(meta::Whitespace::Collapse);
    fn from_literal(normalized: &str) -> Result<Self, meta::Error> {
        let value = dt_builtins::PrimitiveType::<String>::from_literal(normalized)?.into_inner();
        match value.as_str() {
            "W3C members" => Ok(Self::W3cMembers),
            "public" => Ok(Self::Public),
            _ => Err(meta::Error::ValueNotInEnumeration(value.to_string())),
        }
    }
}
#[derive(Debug)]
pub struct TestSuiteResults {
    pub annotations: Vec<Annotation>,
    pub test_results: Vec<TestResult>,
    pub suite: dt_builtins::Name,
    pub processor: String,
    pub submit_date: dt_builtins::Date,
    pub publication_permission: Option<PublicationPermission>,
}
#[derive(Debug)]
pub struct TestResult {
    pub annotations: Vec<Annotation>,
    pub validity: TestOutcome,
    pub set: dt_builtins::Name,
    pub group: dt_builtins::Name,
    pub test: dt_builtins::Name,
    pub normalized_load: Option<dt_builtins::Decimal>,
}
#[derive(Debug)]
pub enum Annotation {
    Appinfo(Appinfo),
    Documentation(Documentation),
}
#[derive(Debug)]
pub struct Appinfo {
    pub wildcard: (),
    pub source: Option<dt_builtins::AnyURI>,
}
#[derive(Debug)]
pub struct Documentation {
    pub wildcard: (),
    pub source: Option<dt_builtins::AnyURI>,
    pub lang: Option<Lang>,
}
